package transactions

import (
	"bytes"
	"encoding/binary"

	"github.com/dusk-network/dusk-blockchain/pkg/p2p/wire/encoding"
	"github.com/dusk-network/dusk-wallet/key"

	"github.com/bwesterb/go-ristretto"
)

type Output struct {
	// Commitment to the amount and the mask value
	// This will be generated by the rangeproof
	Commitment ristretto.Point
	amount     ristretto.Scalar
	mask       ristretto.Scalar

	// PubKey refers to the destination key of the receiver
	// One-time pubkey of the receiver
	// Each input will contain a one-time pubkey
	// Only the private key assosciated with this
	// public key can unlock the funds available at this utxo
	PubKey key.StealthAddress

	// Index denotes the position that this output is in the
	// transaction. This is different to the Offset which denotes the
	// position that this output is in, from the start from the blockchain
	Index uint32

	viewKey         key.PublicView
	EncryptedAmount ristretto.Scalar
	EncryptedMask   ristretto.Scalar
}

func NewOutput(r, amount ristretto.Scalar, index uint32, pubKey key.PublicKey) *Output {
	output := &Output{
		amount:  amount,
		Index:   index,
		PubKey:  *pubKey.StealthAddress(r, index),
		viewKey: *pubKey.PubView,
	}

	return output
}

func sliceToPoint(b []byte) ristretto.Point {
	var bBytes [32]byte
	copy(bBytes[:], b)

	var p ristretto.Point
	p.SetBytes(&bBytes)
	return p
}

func sliceToScalar(b []byte) ristretto.Scalar {
	var bBytes [32]byte
	copy(bBytes[:], b)

	var p ristretto.Scalar
	p.SetBytes(&bBytes)
	return p
}

// Encode an Output struct and write to w.
func MarshalOutput(w *bytes.Buffer, o *Output) error {
	if err := encoding.Write256(w, o.Commitment.Bytes()); err != nil {
		return err
	}

	if err := encoding.Write256(w, o.PubKey.P.Bytes()); err != nil {
		return err
	}

	if err := encoding.WriteVarBytes(w, o.EncryptedAmount.Bytes()); err != nil {
		return err
	}

	if err := encoding.WriteVarBytes(w, o.EncryptedMask.Bytes()); err != nil {
		return err
	}

	return nil
}

// Decode an Output object from r into an output struct.
func UnmarshalOutput(r *bytes.Buffer, o *Output) error {
	commBytes := make([]byte, 32)
	if err := encoding.Read256(r, commBytes); err != nil {
		return err
	}
	o.Commitment.UnmarshalBinary(commBytes)

	pubKeyBytes := make([]byte, 32)
	if err := encoding.Read256(r, pubKeyBytes); err != nil {
		return err
	}
	o.PubKey.P.UnmarshalBinary(pubKeyBytes)

	var encAmountBytes []byte
	if err := encoding.ReadVarBytes(r, &encAmountBytes); err != nil {
		return err
	}
	o.EncryptedAmount.UnmarshalBinary(encAmountBytes)

	var encMaskBytes []byte
	if err := encoding.ReadVarBytes(r, &encMaskBytes); err != nil {
		return err
	}
	o.EncryptedMask.UnmarshalBinary(encMaskBytes)
	return nil
}

// encAmount = amount + H(H(H(r*PubViewKey || index)))
func EncryptAmount(amount, r ristretto.Scalar, index uint32, pubViewKey key.PublicView) ristretto.Scalar {
	rView := pubViewKey.ScalarMult(r)

	rViewIndex := append(rView.Bytes(), uint32ToBytes(index)...)

	var encryptKey ristretto.Scalar
	encryptKey.Derive(rViewIndex)
	encryptKey.Derive(encryptKey.Bytes())
	encryptKey.Derive(encryptKey.Bytes())

	var encryptedAmount ristretto.Scalar
	encryptedAmount.Add(&amount, &encryptKey)

	return encryptedAmount
}

// decAmount = EncAmount - H(H(H(R*PrivViewKey || index)))
func DecryptAmount(encAmount ristretto.Scalar, R ristretto.Point, index uint32, privViewKey key.PrivateView) ristretto.Scalar {

	var Rview ristretto.Point
	pv := (ristretto.Scalar)(privViewKey)
	Rview.ScalarMult(&R, &pv)

	rViewIndex := append(Rview.Bytes(), uint32ToBytes(index)...)

	var encryptKey ristretto.Scalar
	encryptKey.Derive(rViewIndex)
	encryptKey.Derive(encryptKey.Bytes())
	encryptKey.Derive(encryptKey.Bytes())

	var decryptedAmount ristretto.Scalar
	decryptedAmount.Sub(&encAmount, &encryptKey)

	return decryptedAmount
}

// encMask = mask + H(H(r*PubViewKey || index))
func EncryptMask(mask, r ristretto.Scalar, index uint32, pubViewKey key.PublicView) ristretto.Scalar {
	rView := pubViewKey.ScalarMult(r)
	rViewIndex := append(rView.Bytes(), uint32ToBytes(index)...)

	var encryptKey ristretto.Scalar
	encryptKey.Derive(rViewIndex)
	encryptKey.Derive(encryptKey.Bytes())

	var encryptedMask ristretto.Scalar
	encryptedMask.Add(&mask, &encryptKey)

	return encryptedMask
}

// decMask = Encmask - H(H(r*PubViewKey || index))
func DecryptMask(encMask ristretto.Scalar, R ristretto.Point, index uint32, privViewKey key.PrivateView) ristretto.Scalar {
	var Rview ristretto.Point
	pv := (ristretto.Scalar)(privViewKey)
	Rview.ScalarMult(&R, &pv)

	rViewIndex := append(Rview.Bytes(), uint32ToBytes(index)...)

	var encryptKey ristretto.Scalar
	encryptKey.Derive(rViewIndex)
	encryptKey.Derive(encryptKey.Bytes())

	var decryptedMask ristretto.Scalar
	decryptedMask.Sub(&encMask, &encryptKey)

	return decryptedMask
}

func uint32ToBytes(x uint32) []byte {
	a := make([]byte, 4)
	binary.BigEndian.PutUint32(a, x)
	return a
}

// Equals returns true if two outputs are the same
func (o *Output) Equals(out *Output) bool {
	if o == nil || out == nil {
		return false
	}

	if !bytes.Equal(o.Commitment.Bytes(), out.Commitment.Bytes()) {
		return false
	}

	if !bytes.Equal(o.PubKey.P.Bytes(), out.PubKey.P.Bytes()) {
		return false
	}

	if !bytes.Equal(o.EncryptedAmount.Bytes(), out.EncryptedAmount.Bytes()) {
		return false
	}

	return bytes.Equal(o.EncryptedMask.Bytes(), out.EncryptedMask.Bytes())
}
